<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <meta name="Description" content="Put your description here." />
    <base href="/" />

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
        background-color: #ededed;
        --r-main-font-size: 24px;
      }

      .slides {
        width: 75% !important;
      }

      .container {
        top: 0 !important;
        display: flex !important;
        flex-direction: row !important;
      }
      .column {
        flex: 1;
      }

      section {
        text-align: left;
      }
      .details {
        position: absolute;
        top: 0;
        right: 0;
        width: 400px;
      }
    </style>
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/dist/theme/black.css"
    />
    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/plugin/highlight/monokai.css"
    />
    <title>slides-sl</title>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
<fragment language="markdown" animate="by-line with-ancestors">
- point 1
  - point 1b
- point 2   
</fragment>
        </section>
        <section>
          <pre>
<code >
<fragment animate="balanced by-line">

  struct Person {
      name: String, // hehe
      age: u32 //hihi
  }

  let p = Person {
      name: String::from(""),
      age: 0
  };

  impl Battle {
    pub fn new(colors: Vec&lt;ColorConfig&gt;) -> Battle {
        let mut map = [[GameCell::Empty; MAP_HEIGHT]; MAP_WIDTH];

        for color_config in colors.iter() {
            for _ in 0..color_config.number_of_bots {
                if  find_empty_position(&map) {
                    map[x][y] = GameCell::Bot(Bot::new(color_config.color));
                }
            }
        }

        let state = from_matrix(map);

        Battle { state, colors }
    }

    pub fn run(&mut self) {
        let mut app = App::config(Config::new().fps(2));

        let mut fps_counter = FPSCounter::new();

        app.run(|app_state: &mut State, window: &mut Window| {
            for key_event in app_state.keyboard().last_key_events() {
                match key_event {
                    KeyEvent::Pressed(Key::Esc) => app_state.stop(),
                    KeyEvent::Pressed(Key::Q) => app_state.stop(),
                    _ => (),
                }
            }

            fps_counter.update();
            self.update();

            let mut pencil = Pencil::new(window.canvas_mut());

            pencil
                .set_origin(Vec2::xy(1 as usize, 1 as usize))
                .set_foreground(Color::Grey)
                .draw_rect(
                    &RectCharset::double_lines(),
                    Vec2::xy(-1 as isize, -1 as isize),
                    Vec2::xy(MAP_WIDTH * 3 + 2, MAP_HEIGHT * 3 + 2),
                );

            let map = state_to_matrix(self.state.clone());

            for x in 0..MAP_WIDTH {
                for y in 0..MAP_HEIGHT {
                    if let GameCell::Bot(bot) = map[x][y] {
                        pencil.set_foreground(bot.color);
                        pencil.draw_char(
                            format!("{}", bot.energy).as_str().chars().next().unwrap(),
                            Vec2::xy(x * 3, (MAP_HEIGHT - 1 - y) * 3),
                        );
                        let bot_down = Vec2::xy(
                            (x as i32) * 3,
                            ((MAP_HEIGHT as i32) - (y as i32) - 1) * 3 + 1,
                        );
                        let bot_up = Vec2::xy(
                            (x as i32) * 3,
                            ((MAP_HEIGHT as i32) - (y as i32) - 1) * 3 - 1,
                        );
                        let bot_left = Vec2::xy(
                            (x as i32) * 3 - 1,
                            ((MAP_HEIGHT as i32) - (y as i32) - 1) * 3,
                        );
                        let bot_right = Vec2::xy(
                            (x as i32) * 3 + 1,
                            ((MAP_HEIGHT as i32) - (y as i32) - 1) * 3,
                        );

                        if !bot.is_shield_destroyed()
                            && bot.shield_direction.eq(&bot.chainsaw_direction)
                        {
                            match bot.shield_direction {
                                Direction::Down => pencil.draw_char('⤈', bot_down),
                                Direction::Up => pencil.draw_char('⤉', bot_up),
                                Direction::Left => pencil.draw_char('⇷', bot_left),
                                Direction::Right => pencil.draw_char('⇸', bot_right),
                            };
                        } else {
                            if !bot.is_shield_destroyed() {
                                match bot.shield_direction {
                                    Direction::Down => pencil.draw_char('—', bot_down),
                                    Direction::Up => pencil.draw_char('—', bot_up),
                                    Direction::Left => pencil.draw_char('|', bot_left),
                                    Direction::Right => pencil.draw_char('|', bot_right),
                                };
                            }
                            match bot.chainsaw_direction {
                                Direction::Down => pencil.draw_char('↓', bot_down),
                                Direction::Up => pencil.draw_char('↑', bot_up),
                                Direction::Left => pencil.draw_char('←', bot_left),
                                Direction::Right => pencil.draw_char('→', bot_right),
                            };
                        }
                    } else if let GameCell::Resource(resource) = &map[x][y] {
                        pencil.set_foreground(Color::White);
                        pencil.draw_center_text(
                            format!("{}", resource.energy_gain).as_str(),
                            Vec2::xy(x * 3, (MAP_HEIGHT - 1 - y) * 3),
                        );
                    }
                }
            }
        });
    }

    fn strategy_for(&self, color: Color) -> Option&lt;BotStrategy&gt; {
        self.colors
            .iter()
            .find(|c| c.color == color)
            .map(|c| c.strategy)
    }

    fn update(&mut self) {
        let old_map = state_to_matrix(self.state.clone());

        for x in 0..MAP_WIDTH {
            for y in 0..MAP_HEIGHT {
                if let GameCell::Bot(bot) = old_map[x][y] {
                    if let Some(strategy) = self.strategy_for(bot.color) {
                        let actuators = (strategy)(&self.state, Position { x, y });
                        self.state = actuators.execute(x, y, self.state.clone());
                    }
                }
            }
        }
        let mut map = state_to_matrix(self.state.clone());

        for x in 0..MAP_WIDTH {
            for y in 0..MAP_HEIGHT {
                if let GameCell::Bot(bot) = map[x][y] {
                    if bot.energy <= 0 {
                        map[x][y] = GameCell::Empty;
                    }
                }
            }
        }
        let mut rng = rand::thread_rng();
        let generated_resources = rng.gen_range(0..(AVERAGE_RESOURCE_GENERATION_PER_TICK * 2));

        if self.state.resources.len() < MAX_RESOURCES {
            for _ in 0..generated_resources {
                if let Some(Position { x, y }) = find_empty_position(&map) {
                    let energy_gain =
                        rng.gen_range(RESOURCE_MIN_ENERGY_GAIN..RESOURCE_MAX_ENERGY_GAIN);

                    map[x][y] = GameCell::Resource(Resource { energy_gain });
                }
            }
        }

        self.state = from_matrix(map);
    }
}

fn find_empty_position(map: &[[GameCell; MAP_HEIGHT]; MAP_WIDTH]) -> Option&lt;Position&gt; {
    let mut rng = rand::thread_rng();

    loop {
        let x: usize = rng.gen_range(0..MAP_WIDTH);
        let y: usize = rng.gen_range(0..MAP_HEIGHT);

        if let GameCell::Empty = map[x][y] {
            return Some(Position { x, y });
        }
    }
}
</fragment>
</code>
</pre>
        </section>
      </div>
    </div>
    <script type="module">
      import RevealAnimateFragments from "../src/index.js";

      import Reveal from "reveal.js";

      let deck = new Reveal({
        plugins: [RevealAnimateFragments],
      });
      deck.initialize();
    </script>
  </body>
</html>
